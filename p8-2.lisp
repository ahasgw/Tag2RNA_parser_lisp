;;; Recognition matrix class definition
;;;

(defclass recognition-matrix ()
  ((strage :initform (make-hash-table :test 'equal)))
  (:documentation "Recognition matrix class"))

(defun make-recognition-matrix ()
  (make-instance 'recognition-matrix))

(defmethod get-entry ((mat recognition-matrix) key)
  (gethash key mat))

(defmethod add-to-entry ((mat recognition-matrix) key item)
  (pushnew item (get-entry mat key)))

(defmethod initialize-recognition-matrix
           ((mat recognition-matrix)
            (recognizer tag2rna-recognizer))
  (let* ((n (target-string-length recognizer))
         (atree-final (get-atrees-final-symbol-tagged recognizer))
         (t4r (get-atrees-by-types recognizer '(t4rd t4ru)))
         (t4l (get-atrees-by-types recognizer '(t4ld t4lu)))
         (t3r (get-atrees-by-types recognizer '(t3r)))
         (t3l (get-atrees-by-types recognizer '(t3l)))
         (t2  (get-atrees-by-types recognizer '(t2d t2u))))
    (format t "~%Entering initialize")
    (do ((i 0 (+ i 1)))
        ((= i (1- n)))
      (princ #\.)            ; for express progression
      (do ((p 0 (+ p 1)))
          ((= p (1+ i)))
        (add-to-entry mat '(p p i (1+ i)) t4r))
      (do ((r (1+ i) (+ r 1)))
          ((= r (1+ n)))
        (add-to-entry mat '(i (1+ i) r r) t4l))
      (when (pair-p (+ i 1) (+ i 2))
        (do ((p 0 (+ p 1)))
            ((= p (1+ i)))
          (add-to-entry mat '(p p i (+ i 2)) t3r))
        (do ((r (+ i 2) (+ r 1)))
            ((= r (1+ n)))
          (add-to-entry mat '(i (+ i 2) r r) t3l)))
      (do ((k (+ i 1) (+ k 1)))
          ((= k n))
        (when (pair-p (+ i 1) (+ k 1))
          (add-to-entry mat '(i (+ i 1) k (+ k 1)) t2))))
    (princ #\.)            ; for express progression
    (do ((p 0 (+ p 1)))
        ((= p n))
      (add-to-entry mat '(p p (1- n) n) t4r))
    (add-to-entry mat '((1- n) n n n) t4l)
    )
)

(defmacro compute-step (atrees key)
  (let ((atree-s (gensym))
        (atree-t (gensym)))
    `(dolist (,atree-s ,atrees)
       (dolist (,atree-t (get-entry mat ,key)
         (when (eq (atree-tagged-node ,atree-s)
                   (atree-root-node ,atree-t))
           (add-to-entry mat '(i j k l) ,atree-s)
           (return))))))

(defmethod compute-every-steps
           ((mat recognition-matrix)
            (recognizer tag2rna-recognizer))
  (let* ((n (target-string-length recognizer))
         (t2u (get-atrees-by-types recognizer '(t2u)))
         (t2d (get-atrees-by-types recognizer '(t2d)))
         (t3l (get-atrees-by-types recognizer '(t3l)))
         (t3r (get-atrees-by-types recognizer '(t3r)))
         (t4ld (get-atrees-by-types recognizer '(t4ld)))
         (t4lu (get-atrees-by-types recognizer '(t4lu)))
         (t4rd (get-atrees-by-types recognizer '(t4rd)))
         (t4ru (get-atrees-by-types recognizer '(t4ru))))
    (format t "~%Entering compute steps")
    (do ((l 0 (+ l 1))) ((= l (1+ n)))
      (princ #\.)            ; for express progression
      (do ((i l (- i 1))) ((= i -1))
        (do ((j i (+ j 1))) ((= j (1+ l)))
          (do ((k l (- k 1))) ((= k (1- j)))
            (when (and (<= 0 i (1- j) (1+ k) l n)  ;; step(1-1)
                       (pair-p j (1+ k)))
              (compute-step t2u '(i (1- j) (1+ k) l)))
            (when (and (<= 0 (1+ i) j k (1- l) n)  ;; step(1-2)
                       (pair-p (1+ i) l))
              (compute-step t2d '((1+ i) j k (1- l))))
            (when (and (<= 0 (1+ i) (1- j) k l n)  ;; step(2-1)
                       (pair-p (1+ i) j))
              (compute-step t3l '((1+ i) (1- j) k l)))
            (when (and (<= 0 i j (1+ k) (1- l) n)  ;; step(2-2)
                       (pair-p (1+ k) l))
              (compute-step t3r '(i j (1+ k) (1- l))))
            (when (<= 0 (1+ i) j k l n)            ;; step(3-1)
              (compute-step t4ld '((1+ i) j k l)))
            (when (<= 0 i (1- j) k l n)            ;; step(3-2)
              (compute-step t4lu '(i (1- j) k l)))
            (when (<= 0 i j k (1- l) n)            ;; step(3-3)
              (compute-step t4rd '(i j k (1- l))))
            (when (<= 0 i j (1+ k) l n)            ;; step(3-4)
              (compute-step t4ru '(i j (1+ k) l)))
            )
          )
        )
      )
    )
  )

(defmethod accept ((mat recognition-matrix)
                   (recognizer tag2rna-recognizer))
  (format t "~%Entering accept")
  (let ((result nil))
    (do ((j 0 (+ j 1)))
        ((or (= j (1+ n)) result))
      (princ #\.)           ; for express progression
      (dolist (atree (get-entry mat '(0 j j n)))
        (when (member (atree-root-node atree) initials)
          (setf result t)
          (return))))
    (format t (if result
                "~%String was recognized."
                "~%String was NOT recognized."))
    result))

;;;